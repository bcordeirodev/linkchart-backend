name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  DEPLOY_HOST: 138.197.121.81
  PROJECT_PATH: /var/www/linkchartapi
  DOCKER_COMPOSE_FILE: docker-compose.prod.yml

jobs:
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 15

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.LINK_CHART_ACTION_KEY }}

    - name: Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        echo "StrictHostKeyChecking no" >> ~/.ssh/config

    - name: Deploy to server
      run: |
        ssh -o StrictHostKeyChecking=no root@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e  # Exit on any error
          cd ${{ env.PROJECT_PATH }}

          # Fun√ß√£o para rollback em caso de erro
          rollback() {
            echo "üîÑ Executando rollback..."
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down || true

            BACKUP_FILE=$(ls -t .env.backup.* 2>/dev/null | head -1)
            if [ -n "$BACKUP_FILE" ]; then
              echo "üì¶ Restaurando backup: $BACKUP_FILE"
              cp "$BACKUP_FILE" .env
            else
              echo "üìã Usando .env.production como fallback"
              cp .env.production .env
            fi

            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d
            exit 1
          }

          # Limpar backups antigos (manter apenas os 5 mais recentes)
          echo "üßπ Limpando backups antigos..."
          ls -t .env.backup.* 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true

          # Pull latest changes
          echo "‚¨áÔ∏è Baixando altera√ß√µes do reposit√≥rio..."
          git fetch origin
          git reset --hard origin/main

          # Backup current .env if exists
          if [ -f .env ]; then
            echo "üíæ Criando backup do .env atual..."
            cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
          fi

          # Copy production environment
          echo "üìã Copiando configura√ß√µes de produ√ß√£o..."
          cp .env.production .env

          # Configurar JWT_SECRET do GitHub Secrets
          echo "üîê Configurando JWT_SECRET do GitHub Secrets..."
          sed -i "s/JWT_SECRET=.*/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env

          # Valida√ß√µes de configura√ß√£o
          echo "üîß Validando configura√ß√µes cr√≠ticas..."

          # Verificar JWT_SECRET
          JWT_LENGTH=$(grep 'JWT_SECRET=' .env | cut -d'=' -f2 | wc -c)
          if [ "$JWT_LENGTH" -lt 32 ]; then
            echo "‚ùå JWT_SECRET muito curto ($JWT_LENGTH caracteres)"
            rollback
          fi
          echo "‚úÖ JWT_SECRET configurado ($JWT_LENGTH caracteres)"

          # Verificar outras configura√ß√µes
          grep -q "APP_ENV=production" .env && echo "‚úÖ APP_ENV=production" || { echo "‚ùå APP_ENV incorreto"; rollback; }
          grep -q "APP_DEBUG=false" .env && echo "‚úÖ APP_DEBUG=false" || { echo "‚ùå APP_DEBUG incorreto"; rollback; }
          grep -q "DB_PASSWORD=" .env && echo "‚úÖ DB_PASSWORD configurado" || { echo "‚ùå DB_PASSWORD n√£o encontrado"; rollback; }
          grep -q "REDIS_PASSWORD=" .env && echo "‚úÖ REDIS_PASSWORD configurado" || { echo "‚ùå REDIS_PASSWORD n√£o encontrado"; rollback; }

          # Garantir permiss√µes corretas
          chmod 644 .env
          echo "‚úÖ Permiss√µes do .env configuradas"

          # Parar containers graciosamente
          echo "üõë Parando containers..."
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down --timeout 30 || true

          # Limpeza de imagens n√£o utilizadas
          echo "üßπ Limpando imagens Docker n√£o utilizadas..."
          docker image prune -f || true

          # Build com cache otimizado
          echo "üèóÔ∏è Building containers com cache otimizado..."
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --parallel

          # Iniciar containers com health checks
          echo "üöÄ Iniciando containers..."
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

          # Aguardar health checks
          echo "‚è≥ Aguardando health checks dos servi√ßos..."
          timeout 120 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps | grep -E "(healthy|running).*linkchartdb"; do
              echo "‚è≥ Aguardando PostgreSQL..."
              sleep 5
            done
          ' || { echo "‚ùå PostgreSQL n√£o ficou healthy"; rollback; }

          timeout 120 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps | grep -E "(healthy|running).*linkchartredis"; do
              echo "‚è≥ Aguardando Redis..."
              sleep 5
            done
          ' || { echo "‚ùå Redis n√£o ficou healthy"; rollback; }

          timeout 180 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps | grep -E "(healthy|running).*linkchartapi"; do
              echo "‚è≥ Aguardando aplica√ß√£o..."
              sleep 10
            done
          ' || { echo "‚ùå Aplica√ß√£o n√£o ficou healthy"; rollback; }

          echo "‚úÖ Todos os servi√ßos est√£o healthy!"

          # Configurar diret√≥rios e executar setup
          echo "üîß Configurando diret√≥rios e executando setup..."
          docker exec linkchartapi /var/www/setup-production-dirs.sh || { echo "‚ùå Erro no setup"; rollback; }

          # Executar otimiza√ß√µes do Laravel
          echo "‚ö° Executando otimiza√ß√µes da API Laravel..."
          docker exec linkchartapi php /var/www/artisan config:clear || { echo "‚ùå Erro ao limpar config"; rollback; }
          docker exec linkchartapi php /var/www/artisan cache:clear || { echo "‚ùå Erro ao limpar cache"; rollback; }
          docker exec linkchartapi php /var/www/artisan config:cache || { echo "‚ùå Erro ao cachear config"; rollback; }
          docker exec linkchartapi php /var/www/artisan route:cache || { echo "‚ùå Erro ao cachear rotas"; rollback; }

          # Verifica√ß√µes de integridade
          echo "üß™ Executando verifica√ß√µes de integridade..."

          # Verificar JWT no Laravel
          JWT_CONFIG=$(docker exec linkchartapi php /var/www/artisan tinker --execute="echo strlen(config('jwt.secret'));" 2>/dev/null | tail -1 || echo "0")
          if [ "$JWT_CONFIG" -gt 32 ]; then
            echo "‚úÖ JWT_SECRET carregado no Laravel (length: $JWT_CONFIG)"
          else
            echo "‚ùå JWT_SECRET problema no Laravel: $JWT_CONFIG"
            rollback
          fi

          # Testar conex√£o com banco
          if docker exec linkchartapi php /var/www/artisan tinker --execute="DB::connection()->getPdo(); echo 'OK';" 2>/dev/null | grep -q "OK"; then
            echo "‚úÖ Conex√£o com PostgreSQL OK"
          else
            echo "‚ùå Problema na conex√£o com banco"
            rollback
          fi

          # Testar conex√£o com Redis
          if docker exec linkchartapi php /var/www/artisan tinker --execute="Cache::store('redis')->put('test', 'ok'); echo 'OK';" 2>/dev/null | grep -q "OK"; then
            echo "‚úÖ Conex√£o com Redis OK"
          else
            echo "‚ùå Problema na conex√£o com Redis"
            rollback
          fi

          # Health check final
          echo "üè• Executando health check final..."
          sleep 10

          # Tentar at√© 3 vezes com intervalo
          for i in {1..3}; do
            if curl -f -s http://${{ env.DEPLOY_HOST }}/health >/dev/null 2>&1; then
              echo "‚úÖ Health check passou na tentativa $i"
              break
            else
              echo "‚ö†Ô∏è Health check falhou na tentativa $i"
              if [ $i -eq 3 ]; then
                echo "‚ùå Health check falhou ap√≥s 3 tentativas - executando rollback"
                rollback
              fi
              sleep 15
            fi
          done

          echo "üéâ Deployment conclu√≠do com sucesso!"
        ENDSSH

    - name: Verify deployment
      run: |
        echo "üîç Verifica√ß√£o final de produ√ß√£o..."

        # Aguardar estabiliza√ß√£o
        sleep 15

        # Verifica√ß√£o de health check
        if curl -f -s --max-time 10 http://${{ env.DEPLOY_HOST }}/health; then
          echo "‚úÖ Health check passou!"
        else
          echo "‚ùå Health check falhou!"
          exit 1
        fi

        # Teste da API - deve retornar 401 (n√£o autenticado)
        API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://${{ env.DEPLOY_HOST }}/api/links)
        case $API_RESPONSE in
          401)
            echo "‚úÖ API respondendo corretamente (401 - autentica√ß√£o necess√°ria)"
            ;;
          200|422|500)
            echo "‚ö†Ô∏è API respondeu com $API_RESPONSE - verificar se √© esperado"
            ;;
          *)
            echo "‚ùå API resposta inesperada: $API_RESPONSE"
            exit 1
            ;;
        esac

        # Verifica√ß√£o adicional da API - endpoint p√∫blico
        HEALTH_RESPONSE=$(curl -s --max-time 10 http://${{ env.DEPLOY_HOST }}/health | head -c 20)
        if [[ "$HEALTH_RESPONSE" == *"OK"* ]] || [[ "$HEALTH_RESPONSE" == *"healthy"* ]]; then
          echo "‚úÖ API health endpoint OK"
        else
          echo "‚ö†Ô∏è Health endpoint response: $HEALTH_RESPONSE"
        fi

        echo "üéâ Deployment verification completed!"

    - name: Post-deployment monitoring
      if: success()
      run: |
        echo "üìä Executando monitoramento p√≥s-deployment..."

        # Verificar logs do container
        ssh -o StrictHostKeyChecking=no root@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          echo "üìã √öltimas linhas do log da aplica√ß√£o:"
          docker logs linkchartapi --tail 20 | grep -E "(ERROR|WARNING|INFO)" || echo "Nenhum log relevante encontrado"

          echo "üìä Status dos containers:"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps

          echo "üíæ Uso de recursos:"
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
        ENDSSH

    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "üöÄ Production deployment completed successfully!"
          echo ""
          echo "üìä Services Status:"
          echo "  ‚úÖ Laravel API Application"
          echo "  ‚úÖ PostgreSQL Database (with health checks)"
          echo "  ‚úÖ Redis Cache (with health checks)"
          echo "  ‚úÖ Nginx Reverse Proxy"
          echo "  ‚úÖ JWT Authentication"
          echo ""
          echo "üåê Application URL: http://${{ env.DEPLOY_HOST }}"
          echo "üè• Health Check: http://${{ env.DEPLOY_HOST }}/health"
          echo "üì° API Endpoint: http://${{ env.DEPLOY_HOST }}/api"
          echo ""
          echo "‚è±Ô∏è Deployment completed at: $(date)"
        else
          echo "üí• Production deployment failed!"
          echo ""
          echo "‚ùå Deployment failed at stage: ${{ job.status }}"
          echo "üîç Please check the logs above to identify the issue"
          echo "üîÑ Automatic rollback should have been executed"
          echo ""
          echo "üìû Action Required:"
          echo "  1. Check server logs: ssh root@${{ env.DEPLOY_HOST }}"
          echo "  2. Verify container status: docker ps"
          echo "  3. Check application logs: docker logs linkchartapi"
        fi
