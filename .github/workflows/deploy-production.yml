name: üöÄ Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force complete rebuild (no cache)'
        required: false
        default: false
        type: boolean

env:
  DEPLOY_HOST: 138.197.121.81
  PROJECT_PATH: /var/www/linkchartapi
  DOCKER_COMPOSE_FILE: docker-compose.prod.yml

jobs:
  deploy:
    name: üèóÔ∏è Deploy to Production Server
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 20

    steps:
    - name: üì¶ Checkout code
      uses: actions/checkout@v4

    - name: üîê Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.LINK_CHART_ACTION_KEY }}

    - name: üåê Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        echo "StrictHostKeyChecking no" >> ~/.ssh/config

    - name: üöÄ Deploy to Production Server
      run: |
        ssh -o StrictHostKeyChecking=no root@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          set -e  # Exit on any error
          cd ${{ env.PROJECT_PATH }}

          # ==========================================
          # FUN√á√ÉO DE ROLLBACK ROBUSTA
          # ==========================================
          rollback() {
            echo "üîÑ EXECUTANDO ROLLBACK DE EMERG√äNCIA..."

            # Parar containers atuais
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down --timeout 60 || true

            # Restaurar backup mais recente
            BACKUP_FILE=$(ls -t .env.backup.* 2>/dev/null | head -1)
            if [ -n "$BACKUP_FILE" ]; then
              echo "üì¶ Restaurando backup: $BACKUP_FILE"
              cp "$BACKUP_FILE" .env
            else
              echo "üìã Usando .env.production como fallback"
              cp .env.production .env
              sed -i "s/JWT_SECRET=.*/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env
            fi

            # Tentar subir vers√£o anterior
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

            echo "‚ùå ROLLBACK CONCLU√çDO - Verifique o sistema manualmente"
            exit 1
          }

          # ==========================================
          # LIMPEZA E PREPARA√á√ÉO
          # ==========================================
          echo "üßπ Preparando ambiente de produ√ß√£o..."

          # Limpar backups antigos (manter 7 mais recentes)
          ls -t .env.backup.* 2>/dev/null | tail -n +8 | xargs rm -f 2>/dev/null || true

          # Pull das mudan√ßas mais recentes
          echo "‚¨áÔ∏è Baixando c√≥digo atualizado..."
          git fetch origin
          git reset --hard origin/main

          # Backup do .env atual
          if [ -f .env ]; then
            echo "üíæ Backup do .env atual..."
            cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
          fi

          # ==========================================
          # CONFIGURA√á√ÉO DO AMBIENTE PRODUCTION
          # ==========================================
          echo "üìã Configurando ambiente de produ√ß√£o..."

          # Usar .env.production como base (seguindo padr√£o dev)
          cp .env.production .env

          # Injetar JWT_SECRET do GitHub Secrets
          echo "üîê Configurando JWT_SECRET..."
          sed -i "s/JWT_SECRET=placeholder/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env

          # ==========================================
          # VALIDA√á√ïES CR√çTICAS
          # ==========================================
          echo "üîß Validando configura√ß√µes cr√≠ticas..."

          # Verificar JWT_SECRET
          JWT_SECRET=$(grep 'JWT_SECRET=' .env | cut -d'=' -f2)
          JWT_LENGTH=${#JWT_SECRET}
          if [ "$JWT_LENGTH" -lt 32 ]; then
            echo "‚ùå JWT_SECRET muito curto ($JWT_LENGTH chars)"
            rollback
          fi
          echo "‚úÖ JWT_SECRET configurado ($JWT_LENGTH chars)"

          # Validar configura√ß√µes essenciais (.env.production)
          grep -q "APP_ENV=production" .env && echo "‚úÖ APP_ENV=production" || { echo "‚ùå APP_ENV incorreto"; rollback; }
          grep -q "APP_DEBUG=false" .env && echo "‚úÖ APP_DEBUG=false" || { echo "‚ùå APP_DEBUG incorreto"; rollback; }
          grep -q "DB_HOST=linkchartdb" .env && echo "‚úÖ DB_HOST=linkchartdb" || { echo "‚ùå DB_HOST incorreto"; rollback; }
          grep -q "REDIS_HOST=linkchartredis" .env && echo "‚úÖ REDIS_HOST=linkchartredis" || { echo "‚ùå REDIS_HOST incorreto"; rollback; }
          grep -q "DB_PASSWORD=" .env && echo "‚úÖ DB_PASSWORD configurado" || { echo "‚ùå DB_PASSWORD ausente"; rollback; }
          grep -q "REDIS_PASSWORD=" .env && echo "‚úÖ REDIS_PASSWORD configurado" || { echo "‚ùå REDIS_PASSWORD ausente"; rollback; }

          # Definir permiss√µes corretas
          chmod 644 .env
          echo "‚úÖ Permiss√µes do .env configuradas"

          # ==========================================
          # DEPLOYMENT COM ESTRAT√âGIA DEV FUNCIONAL
          # ==========================================
          echo "üõë Parando containers atuais..."
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down --timeout 60 || true

          # Limpeza opcional de imagens (baseado no dev)
          if [ "${{ inputs.force_rebuild }}" = "true" ]; then
            echo "üßπ For√ßando rebuild completo..."
            docker system prune -f
            docker image prune -a -f
          else
            echo "üßπ Limpeza b√°sica..."
            docker image prune -f
          fi

          # Build seguindo o padr√£o que funciona em dev
          echo "üèóÔ∏è Building aplica√ß√£o..."
          if [ "${{ inputs.force_rebuild }}" = "true" ]; then
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache --parallel
          else
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --parallel
          fi

          # Iniciar servi√ßos (igual ao dev)
          echo "üöÄ Iniciando servi√ßos de produ√ß√£o..."
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

          # ==========================================
          # AGUARDAR HEALTH CHECKS (BASEADO NO DEV)
          # ==========================================
          echo "‚è≥ Aguardando servi√ßos ficarem healthy..."

          # PostgreSQL Health Check
          echo "üóÑÔ∏è Aguardando PostgreSQL..."
          timeout 120 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T database pg_isready -U linkchartuser -d linkchartprod >/dev/null 2>&1; do
              echo "‚è≥ PostgreSQL iniciando..."
              sleep 5
            done
          ' || { echo "‚ùå PostgreSQL timeout"; rollback; }
          echo "‚úÖ PostgreSQL healthy"

          # Redis Health Check
          echo "‚ö° Aguardando Redis..."
          timeout 120 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T redis redis-cli -a linkchartredis123 ping >/dev/null 2>&1; do
              echo "‚è≥ Redis iniciando..."
              sleep 5
            done
          ' || { echo "‚ùå Redis timeout"; rollback; }
          echo "‚úÖ Redis healthy"

          # Laravel Application Health Check (similar ao dev)
          echo "üêò Aguardando Laravel Application..."
          timeout 180 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps | grep -q "linkchartapi.*Up"; do
              echo "‚è≥ Laravel iniciando..."
              sleep 10
            done
          ' || { echo "‚ùå Laravel timeout"; rollback; }
          echo "‚úÖ Laravel Application running"

          # ==========================================
          # CONFIGURA√á√ÉO LARAVEL (IGUAL AO DEV)
          # ==========================================
          echo "‚öôÔ∏è Configurando Laravel (baseado no padr√£o dev)..."

          # Aguardar PHP-FPM e Nginx estarem prontos
          sleep 15

          # Setup de diret√≥rios e permiss√µes (igual ao dev)
          docker exec linkchartapi /var/www/setup-production-dirs.sh || { echo "‚ùå Erro no setup dirs"; rollback; }

          # Laravel optimizations (seguindo padr√£o dev mas para prod)
          echo "‚ö° Otimiza√ß√µes Laravel para produ√ß√£o..."
          docker exec linkchartapi php /var/www/artisan config:clear || { echo "‚ùå config:clear falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan cache:clear || { echo "‚ùå cache:clear falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan route:clear || { echo "‚ùå route:clear falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan view:clear || { echo "‚ùå view:clear falhou"; rollback; }

          # Executar migra√ß√µes
          docker exec linkchartapi php /var/www/artisan migrate --force || { echo "‚ùå migrate falhou"; rollback; }

          # Storage link
          docker exec linkchartapi php /var/www/artisan storage:link || { echo "‚ùå storage:link falhou"; rollback; }

          # Cache para produ√ß√£o
          docker exec linkchartapi php /var/www/artisan config:cache || { echo "‚ùå config:cache falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan route:cache || { echo "‚ùå route:cache falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan view:cache || { echo "‚ùå view:cache falhou"; rollback; }

          # ==========================================
          # VERIFICA√á√ïES DE INTEGRIDADE
          # ==========================================
          echo "üß™ Verifica√ß√µes de integridade..."

          # Aguardar estabiliza√ß√£o
          sleep 10

          # Verificar JWT no Laravel
          JWT_TEST=$(docker exec linkchartapi php /var/www/artisan tinker --execute="echo 'JWT_LEN:' . strlen(config('jwt.secret'));" 2>/dev/null | grep 'JWT_LEN:' | cut -d':' -f2 || echo "0")
          if [ "$JWT_TEST" -gt 32 ]; then
            echo "‚úÖ JWT carregado no Laravel (length: $JWT_TEST)"
          else
            echo "‚ùå JWT problema no Laravel: '$JWT_TEST'"
            rollback
          fi

          # Testar Database Connection
          if docker exec linkchartapi php /var/www/artisan tinker --execute="try { DB::connection()->getPdo(); echo 'DB_OK'; } catch(Exception \$e) { echo 'DB_ERROR'; }" 2>/dev/null | grep -q "DB_OK"; then
            echo "‚úÖ PostgreSQL connection OK"
          else
            echo "‚ùå PostgreSQL connection failed"
            rollback
          fi

          # Testar Redis Connection
          if docker exec linkchartapi php /var/www/artisan tinker --execute="try { Cache::store('redis')->put('test_key', 'test_value', 60); echo 'REDIS_OK'; } catch(Exception \$e) { echo 'REDIS_ERROR'; }" 2>/dev/null | grep -q "REDIS_OK"; then
            echo "‚úÖ Redis connection OK"
          else
            echo "‚ùå Redis connection failed"
            rollback
          fi

          # ==========================================
          # HEALTH CHECK FINAL
          # ==========================================
          echo "üè• Health check final da aplica√ß√£o..."
          sleep 15

          # Tentar health check m√∫ltiplas vezes
          for i in {1..5}; do
            if curl -f -s --max-time 15 http://localhost/health >/dev/null 2>&1; then
              echo "‚úÖ Health check passou na tentativa $i"
              break
            else
              echo "‚ö†Ô∏è Health check falhou na tentativa $i"
              if [ $i -eq 5 ]; then
                echo "‚ùå Health check falhou ap√≥s 5 tentativas"
                # Mostrar logs para debug
                echo "üìã Logs do container para debug:"
                docker logs linkchartapi --tail 50
                rollback
              fi
              sleep 20
            fi
          done

          echo "üéâ DEPLOYMENT DE PRODU√á√ÉO CONCLU√çDO COM SUCESSO!"
          echo "üìä Containers ativos:"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps
        ENDSSH

    - name: üîç Verifica√ß√£o Final de Produ√ß√£o
      run: |
        echo "üîç Verifica√ß√£o final completa..."

        # Aguardar estabiliza√ß√£o total
        sleep 20

        # Health Check Principal
        if curl -f -s --max-time 15 http://${{ env.DEPLOY_HOST }}/health; then
          echo "‚úÖ Health check principal OK"
        else
          echo "‚ùå Health check principal falhou"
          exit 1
        fi

        # Teste API - deve retornar 401 (n√£o autenticado)
        API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 http://${{ env.DEPLOY_HOST }}/api/links)
        case $API_RESPONSE in
          401)
            echo "‚úÖ API protegida OK (401 - auth required)"
            ;;
          200|422)
            echo "‚ö†Ô∏è API respondeu $API_RESPONSE (verificar se esperado)"
            ;;
          *)
            echo "‚ùå API resposta inesperada: $API_RESPONSE"
            exit 1
            ;;
        esac

        # Verificar health endpoint detalhado
        HEALTH_FULL=$(curl -s --max-time 15 http://${{ env.DEPLOY_HOST }}/health)
        if [[ "$HEALTH_FULL" == *"OK"* ]] || [[ "$HEALTH_FULL" == *"healthy"* ]]; then
          echo "‚úÖ Health endpoint detalhado OK"
          echo "üìã Health response: $HEALTH_FULL"
        else
          echo "‚ö†Ô∏è Health endpoint response: $HEALTH_FULL"
        fi

        echo "üéâ VERIFICA√á√ÉO DE PRODU√á√ÉO CONCLU√çDA!"

    - name: üìä Monitoramento P√≥s-Deploy
      if: success()
      run: |
        echo "üìä Monitoramento p√≥s-deployment..."

        ssh -o StrictHostKeyChecking=no root@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          cd ${{ env.PROJECT_PATH }}

          echo "üìã Status final dos containers:"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps

          echo ""
          echo "üìà Estat√≠sticas de recursos:"
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"

          echo ""
          echo "üìù √öltimas 10 linhas do log da aplica√ß√£o:"
          docker logs linkchartapi --tail 10

          echo ""
          echo "üîç Verifica√ß√£o final de configura√ß√£o:"
          docker exec linkchartapi php /var/www/artisan --version
          docker exec linkchartapi php /var/www/artisan env | grep -E "APP_ENV|APP_DEBUG|DB_CONNECTION|REDIS_CLIENT" || true
        ENDSSH

    - name: üì¢ Notifica√ß√£o de Status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "üöÄ PRODU√á√ÉO DEPLOYED COM SUCESSO!"
          echo ""
          echo "üìä Servi√ßos Ativos:"
          echo "  ‚úÖ Laravel API Application (PHP 8.2 + FPM)"
          echo "  ‚úÖ PostgreSQL Database 15 (com health checks)"
          echo "  ‚úÖ Redis Cache 7 (com auth)"
          echo "  ‚úÖ Nginx Reverse Proxy"
          echo "  ‚úÖ Supervisor Process Manager"
          echo "  ‚úÖ JWT Authentication"
          echo "  ‚úÖ CORS Configurado"
          echo ""
          echo "üåê URLs de Produ√ß√£o:"
          echo "  üè† Application: http://${{ env.DEPLOY_HOST }}"
          echo "  üè• Health Check: http://${{ env.DEPLOY_HOST }}/health"
          echo "  üì° API Base: http://${{ env.DEPLOY_HOST }}/api"
          echo "  üîê Auth: http://${{ env.DEPLOY_HOST }}/api/auth/login"
          echo ""
          echo "‚è±Ô∏è Deploy conclu√≠do em: $(date)"
          echo "üîß Baseado na estrutura dev funcional + .env.production"
        else
          echo "üí• FALHA NO DEPLOYMENT DE PRODU√á√ÉO!"
          echo ""
          echo "‚ùå Status: ${{ job.status }}"
          echo "üîç Logs acima cont√™m detalhes do erro"
          echo "üîÑ Rollback autom√°tico executado"
          echo ""
          echo "üìû A√ß√µes Necess√°rias:"
          echo "  1. ssh root@${{ env.DEPLOY_HOST }}"
          echo "  2. cd ${{ env.PROJECT_PATH }}"
          echo "  3. docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps"
          echo "  4. docker logs linkchartapi"
          echo "  5. Verificar .env.backup.* para vers√µes anteriores"
          echo ""
          echo "üí° Rollback executado - sistema deve estar na vers√£o anterior"
        fi
