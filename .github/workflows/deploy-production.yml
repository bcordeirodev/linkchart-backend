name: üöÄ Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force complete rebuild (no cache)'
        required: false
        default: false
        type: boolean

env:
  DEPLOY_HOST: 134.209.33.182
  PROJECT_PATH: /var/www/linkchartapi
  DOCKER_COMPOSE_FILE: docker-compose.prod.yml

jobs:
  deploy:
    name: üèóÔ∏è Deploy to Production Server
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 20

    steps:
    - name: üì¶ Checkout code
      uses: actions/checkout@v4

    - name: üîê Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

    - name: üåê Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        echo "Host 134.209.33.182" >> ~/.ssh/config
        echo "    StrictHostKeyChecking no" >> ~/.ssh/config
        echo "    UserKnownHostsFile /dev/null" >> ~/.ssh/config
        echo "    ServerAliveInterval 60" >> ~/.ssh/config
        echo "    ServerAliveCountMax 3" >> ~/.ssh/config
        echo "    ConnectTimeout 30" >> ~/.ssh/config
        echo "    ConnectionAttempts 3" >> ~/.ssh/config

    - name: üìß Configurar SendGrid no .env.production
      run: |
        echo "üîß Atualizando .env.production com SendGrid API Key..."
        # Remover linhas existentes
        sed -i '/^SENDGRID_API_KEY=/d' .env.production
        sed -i '/^MAIL_PASSWORD=/d' .env.production
        # Adicionar API Key real
        echo "SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}" >> .env.production
        echo "MAIL_PASSWORD=${{ secrets.SENDGRID_API_KEY }}" >> .env.production
        echo "‚úÖ SendGrid configurado no .env.production"

    - name: üè• Verificar Conectividade do Servidor
      run: |
        echo "üîç Verificando conectividade SSH do servidor..."

        # Teste m√∫ltiplas portas para verificar conectividade
        echo "üîå Testando conectividade em m√∫ltiplas portas..."

        # Teste porta SSH 22
        SSH_PORT_OK=false
        if timeout 10 nc -zv ${{ env.DEPLOY_HOST }} 22 2>/dev/null; then
          echo "‚úÖ Porta SSH 22 acess√≠vel"
          SSH_PORT_OK=true
        else
          echo "‚ö†Ô∏è Porta SSH 22 n√£o acess√≠vel via netcat"
        fi

        # Teste porta HTTP 80 (alternativa)
        HTTP_PORT_OK=false
        if timeout 10 nc -zv ${{ env.DEPLOY_HOST }} 80 2>/dev/null; then
          echo "‚úÖ Porta HTTP 80 acess√≠vel"
          HTTP_PORT_OK=true
        else
          echo "‚ö†Ô∏è Porta HTTP 80 n√£o acess√≠vel via netcat"
        fi

        # Teste HTTP endpoint (se dispon√≠vel)
        HTTP_OK=false
        if timeout 15 curl -s --max-time 10 --connect-timeout 5 -o /dev/null http://${{ env.DEPLOY_HOST }}/health 2>/dev/null; then
          echo "‚úÖ HTTP endpoint /health acess√≠vel"
          HTTP_OK=true
        elif timeout 15 curl -s --max-time 10 --connect-timeout 5 -o /dev/null http://${{ env.DEPLOY_HOST }}/ 2>/dev/null; then
          echo "‚úÖ HTTP endpoint / acess√≠vel"
          HTTP_OK=true
        else
          echo "‚ö†Ô∏è HTTP endpoints n√£o acess√≠veis"
        fi

        # Avaliar conectividade geral
        if [ "$SSH_PORT_OK" = false ] && [ "$HTTP_PORT_OK" = false ] && [ "$HTTP_OK" = false ]; then
          echo "‚ùå Nenhuma forma de conectividade detectada"
          echo "üîß Poss√≠veis causas:"
          echo "  1. Firewall bloqueando GitHub Actions IPs"
          echo "  2. Servidor completamente offline"
          echo "  3. Rate limiting agressivo"
          echo "  4. Problemas de rede tempor√°rios"
          exit 1
        else
          echo "‚úÖ Pelo menos uma forma de conectividade detectada"
          if [ "$SSH_PORT_OK" = true ]; then
            echo "üì° SSH dispon√≠vel - deploy pode prosseguir"
          else
            echo "‚ö†Ô∏è SSH via netcat falhou, mas tentaremos SSH direto"
          fi
        fi

        # Aguardar um pouco para evitar rate limiting
        echo "‚è≥ Aguardando para evitar rate limiting SSH..."
        sleep 5

        # Teste SSH com retry e configura√ß√µes otimizadas
        SSH_SUCCESS=false
        for attempt in {1..3}; do
          echo "üîÑ Tentativa SSH de conectividade $attempt/3..."

          if timeout 15 ssh \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=5 \
            -o ServerAliveCountMax=2 \
            -o BatchMode=yes \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            root@${{ env.DEPLOY_HOST }} "echo 'SSH Test OK'" >/dev/null 2>&1; then
            echo "‚úÖ SSH conectividade OK na tentativa $attempt"
            SSH_SUCCESS=true
            break
          else
            echo "‚ö†Ô∏è SSH falhou na tentativa $attempt"
            if [ $attempt -lt 3 ]; then
              echo "‚è≥ Aguardando 10s antes da pr√≥xima tentativa..."
              sleep 10
            fi
          fi
        done

        if [ "$SSH_SUCCESS" = false ]; then
          echo "‚ùå SSH connection test failed ap√≥s 3 tentativas"
          echo "üîß Poss√≠veis causas:"
          echo "  1. Rate limiting SSH devido a ataques brute force"
          echo "  2. GitHub Actions IPs bloqueados no firewall"
          echo "  3. Servidor sobrecarregado"
          echo "  4. Problema de rede tempor√°rio"
          echo "  5. SSH daemon com problemas"
          echo ""
          echo "üí° O deploy tentar√° continuar com retry logic mais robusto..."
          # N√£o falhar aqui, deixar o deploy tentar com sua pr√≥pria l√≥gica
        fi

    - name: üöÄ Deploy to Production Server
      run: |
        echo "üîÑ Conectando ao servidor com retry logic robusto..."
        max_attempts=5
        delay=15

        # Teste r√°pido de conectividade antes de tentar deploy
        echo "üîå Verifica√ß√£o final de conectividade..."
        if ! timeout 10 nc -zv ${{ env.DEPLOY_HOST }} 22 2>/dev/null; then
          echo "‚ö†Ô∏è Porta SSH n√£o responde, mas continuando com retry logic..."
        fi

        for attempt in $(seq 1 $max_attempts); do
          echo "üîÑ Tentativa SSH $attempt/$max_attempts..."

          # Aguardar progressivamente mais entre tentativas para evitar rate limiting
          if [ $attempt -gt 1 ]; then
            wait_time=$((delay * attempt))
            echo "‚è≥ Aguardando ${wait_time}s para evitar rate limiting..."
            sleep $wait_time

            # Testar conectividade novamente antes de tentar SSH
            echo "üîå Re-testando conectividade..."
            timeout 5 nc -zv ${{ env.DEPLOY_HOST }} 22 2>/dev/null || echo "‚ö†Ô∏è Porta SSH ainda n√£o responde"
          fi

          if ssh \
            -o ConnectTimeout=15 \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=3 \
            -o BatchMode=yes \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            -o TCPKeepAlive=yes \
            root@${{ env.DEPLOY_HOST }} << ENDSSH
            set -e  # Exit on any error
            cd ${{ env.PROJECT_PATH }}

          # ==========================================
          # FUN√á√ÉO DE ROLLBACK ROBUSTA
          # ==========================================
          rollback() {
            echo "üîÑ EXECUTANDO ROLLBACK DE EMERG√äNCIA..."

            # Parar containers atuais
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down --timeout 60 || true

            # Restaurar backup mais recente
            BACKUP_FILE=$(ls -t .env.backup.* 2>/dev/null | head -1)
            if [ -n "$BACKUP_FILE" ]; then
              echo "üì¶ Restaurando backup: $BACKUP_FILE"
              cp "$BACKUP_FILE" .env
            else
              echo "üìã Usando .env.production como fallback (JWT_SECRET j√° inclu√≠do)"
              cp .env.production .env
            fi

            # Tentar subir vers√£o anterior
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

            echo "‚ùå ROLLBACK CONCLU√çDO - Verifique o sistema manualmente"
            exit 1
          }

          # ==========================================
          # LIMPEZA E PREPARA√á√ÉO
          # ==========================================
          echo "üßπ Preparando ambiente de produ√ß√£o..."

          # Limpar backups antigos (manter 7 mais recentes)
          ls -t .env.backup.* 2>/dev/null | tail -n +8 | xargs rm -f 2>/dev/null || true

          # Pull das mudan√ßas mais recentes
          echo "‚¨áÔ∏è Baixando c√≥digo atualizado..."
          git fetch origin
          git reset --hard origin/main

          # Backup do .env atual
          if [ -f .env ]; then
            echo "üíæ Backup do .env atual..."
            cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
          fi

          # ==========================================
          # CONFIGURA√á√ÉO DO AMBIENTE PRODUCTION
          # ==========================================
          echo "üìã Configurando ambiente de produ√ß√£o..."

          # Usar .env.production como base (seguindo padr√£o dev)
          echo "üìã Copiando .env.production para .env (JWT_SECRET j√° inclu√≠do)..."
          cp .env.production .env

          echo "üìß Verificando SendGrid no .env..."
          if ! grep -q "^SENDGRID_API_KEY=SG\." .env || ! grep -q "^MAIL_PASSWORD=SG\." .env; then
            echo "‚ùå ERRO: SendGrid n√£o configurada no .env"
            rollback
          fi
          echo "‚úÖ SendGrid configurado corretamente"

          # ==========================================
          # VALIDA√á√ïES B√ÅSICAS
          # ==========================================
          echo "üîß Validando configura√ß√µes b√°sicas..."

          # Valida√ß√µes essenciais simplificadas
          grep -q "APP_ENV=production" .env || { echo "‚ùå APP_ENV incorreto"; rollback; }
          grep -q "DB_HOST=linkchartdb" .env || { echo "‚ùå DB_HOST incorreto"; rollback; }

          # Validar configura√ß√£o do SendGrid
          echo "üìß Validando configura√ß√£o SendGrid..."
          grep -q "MAIL_MAILER=smtp" .env || { echo "‚ùå MAIL_MAILER incorreto"; rollback; }
          grep -q "MAIL_HOST=smtp.sendgrid.net" .env || { echo "‚ùå MAIL_HOST incorreto"; rollback; }
          grep -q "MAIL_USERNAME=apikey" .env || { echo "‚ùå MAIL_USERNAME incorreto"; rollback; }

          # Verificar se a API Key do SendGrid foi configurada (deve come√ßar com SG.)
          if grep -q "^MAIL_PASSWORD=SG\." .env; then
            echo "‚úÖ SendGrid API Key configurada corretamente"
          else
            echo "‚ùå ERRO: SendGrid API Key n√£o configurada ou inv√°lida"
            echo "üîç Verificando conte√∫do da MAIL_PASSWORD..."
            grep "MAIL_PASSWORD=" .env | head -1
            rollback
          fi

          chmod 644 .env
          echo "‚úÖ Configura√ß√µes b√°sicas e SendGrid validadas"

          # ==========================================
          # DEPLOYMENT COM ESTRAT√âGIA DEV FUNCIONAL
          # ==========================================
          echo "üõë Parando containers atuais..."
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down --timeout 60 || true

          # Limpeza opcional de imagens (baseado no dev)
          if [ "${{ inputs.force_rebuild }}" = "true" ]; then
            echo "üßπ For√ßando rebuild completo..."
            docker system prune -f
            docker image prune -a -f
          else
            echo "üßπ Limpeza b√°sica..."
            docker image prune -f
          fi

          # Build seguindo o padr√£o que funciona em dev
          echo "üèóÔ∏è Building aplica√ß√£o..."
          if [ "${{ inputs.force_rebuild }}" = "true" ]; then
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache --parallel
          else
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --parallel
          fi

          # Iniciar servi√ßos (igual ao dev)
          echo "üöÄ Iniciando servi√ßos de produ√ß√£o..."
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

          # ==========================================
          # AGUARDAR HEALTH CHECKS (BASEADO NO DEV)
          # ==========================================
          echo "‚è≥ Aguardando servi√ßos ficarem healthy..."

          # PostgreSQL Health Check
          echo "üóÑÔ∏è Aguardando PostgreSQL..."
          timeout 120 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T database pg_isready -U linkchartuser -d linkchartprod >/dev/null 2>&1; do
              echo "‚è≥ PostgreSQL iniciando..."
              sleep 5
            done
          ' || { echo "‚ùå PostgreSQL timeout"; rollback; }
          echo "‚úÖ PostgreSQL healthy"

          # Redis Health Check
          echo "‚ö° Aguardando Redis..."
          timeout 120 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T redis redis-cli -a linkchartredis123 ping >/dev/null 2>&1; do
              echo "‚è≥ Redis iniciando..."
              sleep 5
            done
          ' || { echo "‚ùå Redis timeout"; rollback; }
          echo "‚úÖ Redis healthy"

          # Laravel Application Health Check (similar ao dev)
          echo "üêò Aguardando Laravel Application..."
          timeout 180 bash -c '
            until docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps | grep -q "linkchartapi.*Up"; do
              echo "‚è≥ Laravel iniciando..."
              sleep 10
            done
          ' || { echo "‚ùå Laravel timeout"; rollback; }
          echo "‚úÖ Laravel Application running"

          # ==========================================
          # CONFIGURA√á√ÉO LARAVEL (IGUAL AO DEV)
          # ==========================================
          echo "‚öôÔ∏è Configurando Laravel (baseado no padr√£o dev)..."

          # Aguardar PHP-FPM e Nginx estarem prontos
          sleep 15


          # ==========================================
          # SETUP DE DIRET√ìRIOS E PERMISS√ïES
          # ==========================================
          echo "üîß Configurando diret√≥rios e permiss√µes..."

          # Copiar script de permiss√µes (faz tudo: diret√≥rios + ownership + permiss√µes)
          docker cp docker/scripts/fix-permissions.sh linkchartapi:/var/www/fix-permissions.sh

          # Tornar script execut√°vel
          docker exec linkchartapi chmod +x /var/www/fix-permissions.sh

          # Executar configura√ß√£o completa (diret√≥rios + permiss√µes)
          docker exec linkchartapi /var/www/fix-permissions.sh || { echo "‚ùå Erro na configura√ß√£o de permiss√µes"; rollback; }

          # ==========================================
          # CONFIGURA√á√ÉO B√ÅSICA DE CACHE
          # ==========================================
          echo "üóÇÔ∏è Configurando cache b√°sico..."
          docker exec linkchartapi mkdir -p /var/www/storage/framework/cache/data
          docker exec linkchartapi chmod -R 775 /var/www/storage/framework/cache
          docker exec linkchartapi chown -R www-data:www-data /var/www/storage/framework/cache
          echo "‚úÖ Cache configurado"

          # VERIFICA√á√ÉO CR√çTICA: Garantir que sistema de logs funciona ANTES de continuar
          echo "üîç Verifica√ß√£o cr√≠tica do sistema de logs..."

          # CORRE√á√ÉO PREVENTIVA AGRESSIVA DE LOGS
          echo "üîß Aplicando corre√ß√£o preventiva agressiva de logs..."
          docker exec linkchartapi mkdir -p /var/www/storage/logs
          docker exec linkchartapi chmod -R 777 /var/www/storage/logs/
          docker exec linkchartapi chown -R www-data:www-data /var/www/storage/logs/

          # Criar arquivo de log principal se n√£o existir
          CURRENT_DATE=$(date +%Y-%m-%d)
          docker exec linkchartapi touch /var/www/storage/logs/laravel.log
          docker exec linkchartapi touch /var/www/storage/logs/laravel-$CURRENT_DATE.log
          docker exec linkchartapi chmod 666 /var/www/storage/logs/laravel.log
          docker exec linkchartapi chmod 666 /var/www/storage/logs/laravel-$CURRENT_DATE.log
          docker exec linkchartapi chown www-data:www-data /var/www/storage/logs/laravel.log
          docker exec linkchartapi chown www-data:www-data /var/www/storage/logs/laravel-$CURRENT_DATE.log

          # Testar sistema de logs
          LOG_TEST_RESULT=$(docker exec linkchartapi sh -c "echo 'DEPLOY_TEST_LOG_ENTRY' >> /var/www/storage/logs/laravel-$CURRENT_DATE.log 2>&1 && echo 'SUCCESS' || echo 'FAILED'")

          if [ "$LOG_TEST_RESULT" != "SUCCESS" ]; then
            echo "‚ùå ERRO CR√çTICO: Sistema de logs n√£o funciona ap√≥s corre√ß√£o preventiva"
            echo "üîß Aplicando corre√ß√£o emergencial M√ÅXIMA..."
            docker exec linkchartapi chmod -R 777 /var/www/storage/
            docker exec linkchartapi chown -R www-data:www-data /var/www/storage/

            # Testar novamente
            LOG_TEST_RESULT2=$(docker exec linkchartapi sh -c "echo 'DEPLOY_EMERGENCY_FIX_TEST' >> /var/www/storage/logs/laravel-$CURRENT_DATE.log 2>&1 && echo 'SUCCESS' || echo 'FAILED'")
            if [ "$LOG_TEST_RESULT2" != "SUCCESS" ]; then
              echo "‚ùå FALHA CR√çTICA: Sistema de logs n√£o funciona mesmo ap√≥s corre√ß√£o emergencial m√°xima"
              echo "üîç Debug: Verificando estrutura de diret√≥rios..."
              docker exec linkchartapi ls -la /var/www/storage/
              docker exec linkchartapi ls -la /var/www/storage/logs/
              rollback
            else
              echo "‚úÖ Sistema de logs corrigido com corre√ß√£o emergencial m√°xima"
            fi
          else
            echo "‚úÖ Sistema de logs funcionando corretamente ap√≥s corre√ß√£o preventiva"
          fi

          # ==========================================
          # OTIMIZA√á√ïES LARAVEL
          # ==========================================
          echo "‚ö° Otimiza√ß√µes Laravel..."
          docker exec linkchartapi php /var/www/artisan config:clear || { echo "‚ùå config:clear falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan cache:clear || { echo "‚ùå cache:clear falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan route:clear || { echo "‚ùå route:clear falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan view:clear || { echo "‚ùå view:clear falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan storage:link || { echo "‚ùå storage:link falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan config:cache || { echo "‚ùå config:cache falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan route:cache || { echo "‚ùå route:cache falhou"; rollback; }
          docker exec linkchartapi php /var/www/artisan view:cache || { echo "‚ùå view:cache falhou"; rollback; }

          # ==========================================
          # EXECUTAR MIGRA√á√ïES (ORDEM CORRETA - AP√ìS CONFIGURA√á√ÉO COMPLETA)
          # ==========================================
          echo "üóÑÔ∏è Executando migra√ß√µes de banco de dados (AP√ìS configura√ß√£o completa)..."

          # Aguardar mais um pouco para garantir estabilidade total
          sleep 10

          # Verificar status das migrations primeiro
          echo "üìã Verificando status das migrations..."
          docker exec linkchartapi php /var/www/artisan migrate:status || { echo "‚ùå migrate:status falhou"; rollback; }

          # Executar migrations com retry logic melhorado
          echo "üîÑ Executando migrations..."
          MIGRATION_SUCCESS=false
          for attempt in {1..5}; do
            echo "üîÑ Tentativa de migration $attempt/5..."

            # Aguardar entre tentativas (exceto primeira)
            if [ $attempt -gt 1 ]; then
              wait_time=$((10 * attempt))
              echo "‚è≥ Aguardando ${wait_time}s antes da tentativa $attempt..."
              sleep $wait_time
            fi

            if docker exec linkchartapi php /var/www/artisan migrate --force; then
              echo "‚úÖ Migrations executadas com sucesso na tentativa $attempt"
              MIGRATION_SUCCESS=true
              break
            else
              echo "‚ö†Ô∏è Migration falhou na tentativa $attempt"
              if [ $attempt -lt 5 ]; then
                echo "üîÑ Tentando novamente..."
                # Mostrar logs para debug
                echo "üìã √öltimas linhas do log Laravel:"
                docker logs linkchartapi --tail 10 2>/dev/null || echo "N√£o foi poss√≠vel obter logs"
              fi
            fi
          done

          if [ "$MIGRATION_SUCCESS" = false ]; then
            echo "‚ùå ERRO CR√çTICO: Migrations falharam ap√≥s 5 tentativas"
            echo "üìã Verificando logs do Laravel..."
            docker logs linkchartapi --tail 30
            rollback
          fi

          # Verificar status final das migrations
          echo "üìã Verificando status final das migrations..."
          docker exec linkchartapi php /var/www/artisan migrate:status

          echo "üéâ MIGRATIONS EXECUTADAS COM SUCESSO!"

          # ==========================================
          # CORRE√á√ÉO FINAL DE PERMISS√ïES (AP√ìS MIGRATIONS)
          # ==========================================
          echo "üîß Aplicando corre√ß√£o final AGRESSIVA de permiss√µes nos logs..."

          # Corre√ß√£o AGRESSIVA de permiss√µes que podem ter sido alteradas durante migrations
          echo "üîß Aplicando permiss√µes 777 em todo storage/ para garantir funcionamento..."
          docker exec linkchartapi chmod -R 777 /var/www/storage/ || echo "‚ö†Ô∏è Aviso: chmod storage falhou"
          docker exec linkchartapi chown -R www-data:www-data /var/www/storage/ || echo "‚ö†Ô∏è Aviso: chown storage falhou"

          # Garantir que arquivos de log espec√≠ficos existam e tenham permiss√µes corretas
          CURRENT_DATE=$(date +%Y-%m-%d)
          docker exec linkchartapi touch /var/www/storage/logs/laravel.log
          docker exec linkchartapi touch /var/www/storage/logs/laravel-$CURRENT_DATE.log
          docker exec linkchartapi touch /var/www/storage/logs/api-errors-$CURRENT_DATE.log
          docker exec linkchartapi chmod 666 /var/www/storage/logs/*.log 2>/dev/null || true
          docker exec linkchartapi chown www-data:www-data /var/www/storage/logs/*.log 2>/dev/null || true

          # Testar se o sistema de logs funciona com m√∫ltiplos testes
          echo "üß™ Testando sistema de logs ap√≥s migrations..."

          # Teste 1: Arquivo direto
          TEST1_RESULT=$(docker exec linkchartapi sh -c "echo 'Deploy test direct: $(date)' >> /var/www/storage/logs/deploy-test.log 2>&1 && echo 'SUCCESS' || echo 'FAILED'")

          # Teste 2: Via PHP
          TEST2_RESULT=$(docker exec linkchartapi php -r "file_put_contents('/var/www/storage/logs/deploy-test-php.log', 'Deploy test PHP: ' . date('Y-m-d H:i:s') . PHP_EOL, FILE_APPEND); echo 'SUCCESS';" 2>/dev/null || echo "FAILED")

          # Teste 3: Laravel log
          TEST3_RESULT=$(docker exec linkchartapi sh -c "echo 'Deploy test Laravel: $(date)' >> /var/www/storage/logs/laravel.log 2>&1 && echo 'SUCCESS' || echo 'FAILED'")

          if [ "$TEST1_RESULT" != "SUCCESS" ] || [ "$TEST2_RESULT" != "SUCCESS" ] || [ "$TEST3_RESULT" != "SUCCESS" ]; then
            echo "‚ùå ERRO: Algum teste de log falhou (T1:$TEST1_RESULT, T2:$TEST2_RESULT, T3:$TEST3_RESULT)"
            echo "üîß Aplicando corre√ß√£o emergencial M√ÅXIMA..."
            docker exec linkchartapi chmod -R 777 /var/www/storage/
            docker exec linkchartapi chown -R www-data:www-data /var/www/storage/

            # Recriar arquivos de log com permiss√µes m√°ximas
            docker exec linkchartapi rm -f /var/www/storage/logs/*.log 2>/dev/null || true
            docker exec linkchartapi touch /var/www/storage/logs/laravel.log
            docker exec linkchartapi chmod 666 /var/www/storage/logs/laravel.log
            docker exec linkchartapi chown www-data:www-data /var/www/storage/logs/laravel.log

            echo "‚úÖ Corre√ß√£o emergencial aplicada - logs devem funcionar agora"
          else
            echo "‚úÖ Todos os testes de log passaram - sistema funcionando corretamente"
          fi

          echo "‚úÖ Corre√ß√£o final de permiss√µes conclu√≠da!"

          # ==========================================
          # VERIFICA√á√ïES B√ÅSICAS
          # ==========================================
          echo "üß™ Verifica√ß√µes b√°sicas..."
          sleep 10

          # Testar conex√µes b√°sicas
          docker exec linkchartapi php /var/www/artisan tinker --execute="DB::connection()->getPdo(); echo 'DB_OK';" 2>/dev/null | grep -q "DB_OK" || rollback
          docker exec linkchartapi php /var/www/artisan tinker --execute="Cache::store('redis')->put('test', 'ok', 60); echo 'REDIS_OK';" 2>/dev/null | grep -q "REDIS_OK" || rollback
          echo "‚úÖ Conex√µes b√°sicas OK"

          # Testar configura√ß√£o de email SendGrid
          echo "üìß Testando configura√ß√£o SendGrid..."
          EMAIL_TEST_RESULT=$(docker exec linkchartapi php /var/www/artisan email:test test@linkcharts.com.br --name="Deploy Test" 2>&1 | grep -E "(‚úÖ|‚ùå)" | tail -1 || echo "TIMEOUT")

          if [[ "$EMAIL_TEST_RESULT" == *"‚úÖ"* ]]; then
            echo "‚úÖ Configura√ß√£o SendGrid OK"
          else
            echo "‚ö†Ô∏è Configura√ß√£o SendGrid com problemas: $EMAIL_TEST_RESULT"
            echo "üìã Continuando deploy (email n√£o √© cr√≠tico para funcionamento b√°sico)"
          fi

          # ==========================================
          # HEALTH CHECK FINAL
          # ==========================================
          echo "üè• Health check final da aplica√ß√£o..."
          sleep 15

          # Tentar health check m√∫ltiplas vezes
          for i in {1..5}; do
            if curl -f -s --max-time 15 http://localhost:8000/health >/dev/null 2>&1; then
              echo "‚úÖ Health check passou na tentativa $i"
              break
            else
              echo "‚ö†Ô∏è Health check falhou na tentativa $i"
              if [ $i -eq 5 ]; then
                echo "‚ùå Health check falhou ap√≥s 5 tentativas"
                # Mostrar logs para debug
                echo "üìã Logs do container para debug:"
                docker logs linkchartapi --tail 50
                rollback
              fi
              sleep 20
            fi
          done

            echo "üéâ DEPLOYMENT DE PRODU√á√ÉO CONCLU√çDO COM SUCESSO!"
            echo "üìä Containers ativos:"
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps
        ENDSSH
          then
            echo "‚úÖ SSH connection successful on attempt $attempt"
            break
          else
            echo "‚ùå SSH failed on attempt $attempt"
            if [ $attempt -eq $max_attempts ]; then
              echo "üí• SSH failed after $max_attempts attempts"
              echo "üîß Troubleshooting steps:"
              echo "  1. SSH rate limiting due to brute force attacks"
              echo "  2. Check server status: ssh root@${{ env.DEPLOY_HOST }}"
              echo "  3. Check SSH logs: journalctl -u ssh -n 20"
              echo "  4. Restart SSH if needed: systemctl restart sshd"
              exit 1
            fi
            echo "‚è≥ SSH attempt failed, will retry with increased delay..."
          fi
        done

    - name: üîç Verifica√ß√£o Final de Produ√ß√£o
      run: |
        echo "üîç Verifica√ß√£o final completa..."

        # Aguardar estabiliza√ß√£o total
        sleep 20

        # Health Check Principal
        if curl -f -k -s --max-time 15 https://api.linkcharts.com.br/health; then
          echo "‚úÖ Health check principal OK"
        else
          echo "‚ùå Health check principal falhou"
          exit 1
        fi

        # Teste API - deve retornar 401 (n√£o autenticado)
        API_RESPONSE=$(curl -s -k -o /dev/null -w "%{http_code}" --max-time 15 https://api.linkcharts.com.br/api/links)
        case $API_RESPONSE in
          401)
            echo "‚úÖ API protegida OK (401 - auth required)"
            ;;
          200|422)
            echo "‚ö†Ô∏è API respondeu $API_RESPONSE (verificar se esperado)"
            ;;
          *)
            echo "‚ùå API resposta inesperada: $API_RESPONSE"
            exit 1
            ;;
        esac

        # Verificar health endpoint detalhado
        HEALTH_FULL=$(curl -s -k --max-time 15 https://api.linkcharts.com.br/health)
        if [[ "$HEALTH_FULL" == *"OK"* ]] || [[ "$HEALTH_FULL" == *"healthy"* ]]; then
          echo "‚úÖ Health endpoint detalhado OK"
          echo "üìã Health response: $HEALTH_FULL"
        else
          echo "‚ö†Ô∏è Health endpoint response: $HEALTH_FULL"
        fi

        echo "üéâ VERIFICA√á√ÉO DE PRODU√á√ÉO CONCLU√çDA!"

    - name: üìä Monitoramento P√≥s-Deploy
      if: success()
      run: |
        echo "üìä Monitoramento p√≥s-deployment..."

        ssh -o StrictHostKeyChecking=no root@${{ env.DEPLOY_HOST }} << 'ENDSSH'
          cd ${{ env.PROJECT_PATH }}

          echo "üìã Status final dos containers:"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps

          echo ""
          echo "üìà Estat√≠sticas de recursos:"
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"

          echo ""
          echo "üìù √öltimas 10 linhas do log da aplica√ß√£o:"
          docker logs linkchartapi --tail 10

          echo ""
          echo "üîç Verifica√ß√£o final de configura√ß√£o:"
          docker exec linkchartapi php /var/www/artisan --version
          docker exec linkchartapi php /var/www/artisan env | grep -E "APP_ENV|APP_DEBUG|DB_CONNECTION|REDIS_CLIENT" || true
        ENDSSH

    - name: üì¢ Notifica√ß√£o de Status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "üöÄ PRODU√á√ÉO DEPLOYED COM SUCESSO!"
          echo ""
          echo "üìä Servi√ßos Ativos:"
          echo "  ‚úÖ Laravel API Application (PHP 8.2 + FPM)"
          echo "  ‚úÖ PostgreSQL Database 15 (com health checks)"
          echo "  ‚úÖ Redis Cache 7 (com auth)"
          echo "  ‚úÖ Nginx Reverse Proxy"
          echo "  ‚úÖ Supervisor Process Manager"
          echo "  ‚úÖ JWT Authentication"
          echo "  ‚úÖ CORS Configurado"
          echo ""
          echo "üåê URLs de Produ√ß√£o:"
          echo "  üè† Application: https://api.linkcharts.com.br"
          echo "  üè• Health Check: https://api.linkcharts.com.br/health"
          echo "  üì° API Base: https://api.linkcharts.com.br/api"
          echo "  üîê Auth: https://api.linkcharts.com.br/api/auth/login"
          echo ""
          echo "‚è±Ô∏è Deploy conclu√≠do em: $(date)"
          echo "üîß Baseado na estrutura dev funcional + .env.production"
        else
          echo "üí• FALHA NO DEPLOYMENT DE PRODU√á√ÉO!"
          echo ""
          echo "‚ùå Status: ${{ job.status }}"
          echo "üîç Logs acima cont√™m detalhes do erro"
          echo "üîÑ Rollback autom√°tico executado"
          echo ""
          echo "üìû A√ß√µes Necess√°rias:"
          echo "  1. ssh root@${{ env.DEPLOY_HOST }}"
          echo "  2. cd ${{ env.PROJECT_PATH }}"
          echo "  3. docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps"
          echo "  4. docker logs linkchartapi"
          echo "  5. Verificar .env.backup.* para vers√µes anteriores"
          echo ""
          echo "üí° Rollback executado - sistema deve estar na vers√£o anterior"
        fi
