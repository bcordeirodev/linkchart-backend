<?php

namespace App\Http\Controllers;

use App\Contracts\Services\LinkServiceInterface;
use App\Services\LinkTrackingService;
use Illuminate\Http\Request;

/**
 * Controller para redirecionamento de links encurtados
 *
 * Segue os princ√≠pios SOLID:
 * - SRP: Respons√°vel apenas pelo redirecionamento de links
 * - DIP: Depende de abstra√ß√µes (interfaces)
 */
class RedirectController
{
    public function __construct(
        protected LinkServiceInterface $linkService,
        protected LinkTrackingService $linkTrackingService
    ) {}

    /**
     * Processa o redirecionamento de um link encurtado.
     * Suporta modo preview (sem registrar clique) e modo redirect (com clique).
     *
     * @param string $slug
     * @param Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function handle(string $slug, Request $request)
    {
        try {
            // Busca o link antes de processar
            $link = \App\Models\Link::where('slug', $slug)
                                  ->where('is_active', true)
                                  ->first();

            if (!$link) {
                return response()->json([
                    'error' => 'Link n√£o encontrado',
                    'message' => 'O link solicitado n√£o foi encontrado ou est√° inativo.'
                ], 404);
            }

            // Verifica se o link n√£o expirou
            if ($link->expires_at && now()->isAfter($link->expires_at)) {
                return response()->json([
                    'error' => 'Link expirado',
                    'message' => 'Este link expirou e n√£o est√° mais dispon√≠vel.'
                ], 404);
            }

            // Verifica se j√° pode ser usado (starts_in)
            if ($link->starts_in && now()->isBefore($link->starts_in)) {
                return response()->json([
                    'error' => 'Link n√£o dispon√≠vel',
                    'message' => 'Este link ainda n√£o est√° dispon√≠vel.'
                ], 404);
            }

            // Verifica se √© modo preview (n√£o registra clique)
            $isPreview = $request->has('preview') || $request->header('X-Preview-Mode') === 'true';

            if (!$isPreview) {
                // SISTEMA ROBUSTO DE M√âTRICAS - NUNCA FALHA O REDIRECIONAMENTO
                $this->processMetricsWithFallback($link, $request, $slug);
            }

            // Retorna dados do link (com ou sem registro de clique)
            return response()->json([
                'success' => true,
                'redirect_url' => $link->original_url,
                'is_preview' => $isPreview,
                'data' => [
                    'id' => $link->id,
                    'user_id' => $link->user_id,
                    'slug' => $link->slug,
                    'original_url' => $link->original_url,
                    'title' => $link->title,
                    'description' => $link->description,
                    'expires_at' => $link->expires_at,
                    'starts_in' => $link->starts_in,
                    'is_active' => $link->is_active,
                    'created_at' => $link->created_at->format('d/m/Y H:i:s'),
                    'updated_at' => $link->updated_at->format('d/m/Y H:i:s'),
                    'is_expired' => $link->expires_at && now()->isAfter($link->expires_at),
                    'is_active_valid' => $link->is_active,
                    'shorted_url' => $link->shorted_url ?? "http://localhost:3000/r/{$link->slug}",
                    'clicks' => $link->clicks,
                    'utm_source' => $link->utm_source,
                    'utm_medium' => $link->utm_medium,
                    'utm_campaign' => $link->utm_campaign,
                    'utm_term' => $link->utm_term,
                    'utm_content' => $link->utm_content,
                ]
            ]);
        } catch (\Exception $e) {
            // Log do erro para debugging
            \Log::error('Erro no processamento do link', [
                'slug' => $slug,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return response()->json([
                'error' => 'Erro interno do servidor',
                'message' => 'Ocorreu um erro ao processar o link.'
            ], 500);
        }
    }

    /**
     * Processa m√©tricas com sistema de fallback ultra-robusto.
     * GARANTIA: Este m√©todo NUNCA lan√ßa exce√ß√µes que possam quebrar o redirecionamento.
     *
     * @param \App\Models\Link $link
     * @param Request $request
     * @param string $slug
     * @return void
     */
    private function processMetricsWithFallback($link, Request $request, string $slug): void
    {
        $metricsContext = [
            'slug' => $slug,
            'link_id' => $link->id,
            'ip' => $request->ip(),
            'user_agent' => $request->userAgent(),
            'referer' => $request->headers->get('referer'),
            'timestamp' => now()->toISOString(),
        ];

        // N√çVEL 1: Tentativa principal de tracking
        $trackingSuccess = $this->attemptTracking($link, $request, $metricsContext);

        // N√çVEL 2: Incremento de cliques (sempre tenta, mesmo se tracking falhar)
        $clickIncrementSuccess = $this->attemptClickIncrement($link, $metricsContext);

        // N√çVEL 3: Log de m√©tricas (sempre executa, independente dos anteriores)
        $this->logMetricsResult($trackingSuccess, $clickIncrementSuccess, $metricsContext);

        // N√çVEL 4: Fallback de emerg√™ncia se tudo falhar
        if (!$trackingSuccess && !$clickIncrementSuccess) {
            $this->emergencyMetricsFallback($link, $metricsContext);
        }
    }

    /**
     * Tentativa de tracking com isolamento total de erros.
     *
     * @param \App\Models\Link $link
     * @param Request $request
     * @param array $context
     * @return bool
     */
    private function attemptTracking($link, Request $request, array $context): bool
    {
        try {
            $this->linkTrackingService->registrarClique($link, $request);

            // Log de sucesso detalhado
            \Log::info('‚úÖ Tracking successful', array_merge($context, [
                'tracking_service' => 'LinkTrackingService',
                'status' => 'success'
            ]));

            return true;
        } catch (\Throwable $e) {
            // Log detalhado do erro, mas N√ÉO propaga exce√ß√£o
            \Log::error('‚ùå Tracking service failed', array_merge($context, [
                'error_type' => get_class($e),
                'error_message' => $e->getMessage(),
                'error_file' => $e->getFile(),
                'error_line' => $e->getLine(),
                'tracking_service' => 'LinkTrackingService',
                'status' => 'failed',
                'fallback_required' => true
            ]));

            return false;
        }
    }

    /**
     * Tentativa de incremento de cliques com isolamento de erros.
     *
     * @param \App\Models\Link $link
     * @param array $context
     * @return bool
     */
    private function attemptClickIncrement($link, array $context): bool
    {
        try {
            $link->increment('clicks');

            \Log::info('‚úÖ Click increment successful', array_merge($context, [
                'new_click_count' => $link->fresh()->clicks,
                'operation' => 'click_increment',
                'status' => 'success'
            ]));

            return true;
        } catch (\Throwable $e) {
            // Tenta fallback com query direta
            try {
                \DB::table('links')
                    ->where('id', $link->id)
                    ->increment('clicks');

                \Log::warning('‚ö†Ô∏è Click increment via fallback', array_merge($context, [
                    'error_message' => $e->getMessage(),
                    'fallback_method' => 'direct_db_query',
                    'status' => 'success_via_fallback'
                ]));

                return true;
            } catch (\Throwable $fallbackError) {
                \Log::error('‚ùå Click increment failed completely', array_merge($context, [
                    'primary_error' => $e->getMessage(),
                    'fallback_error' => $fallbackError->getMessage(),
                    'operation' => 'click_increment',
                    'status' => 'failed'
                ]));

                return false;
            }
        }
    }

    /**
     * Log consolidado do resultado das m√©tricas.
     *
     * @param bool $trackingSuccess
     * @param bool $clickIncrementSuccess
     * @param array $context
     * @return void
     */
    private function logMetricsResult(bool $trackingSuccess, bool $clickIncrementSuccess, array $context): void
    {
        try {
            $status = 'success';
            $icon = '‚úÖ';

            if (!$trackingSuccess && !$clickIncrementSuccess) {
                $status = 'total_failure';
                $icon = 'üö®';
            } elseif (!$trackingSuccess || !$clickIncrementSuccess) {
                $status = 'partial_failure';
                $icon = '‚ö†Ô∏è';
            }

            $logData = array_merge($context, [
                'metrics_summary' => [
                    'tracking_success' => $trackingSuccess,
                    'click_increment_success' => $clickIncrementSuccess,
                    'overall_status' => $status
                ],
                'redirect_status' => 'proceeding_normally'
            ]);

            if ($status === 'success') {
                \Log::info("$icon Redirect metrics completed successfully", $logData);
            } else {
                \Log::warning("$icon Redirect metrics had issues but redirect proceeding", $logData);
            }
        } catch (\Throwable $e) {
            // Se at√© o log falhar, usa error_log como √∫ltimo recurso
            error_log("LinkChart: Metrics logging failed for slug {$context['slug']} - " . $e->getMessage());
        }
    }

    /**
     * Fallback de emerg√™ncia quando tudo mais falha.
     *
     * @param \App\Models\Link $link
     * @param array $context
     * @return void
     */
    private function emergencyMetricsFallback($link, array $context): void
    {
        try {
            // Tenta salvar m√©tricas b√°sicas em arquivo como √∫ltimo recurso
            $emergencyData = [
                'timestamp' => $context['timestamp'],
                'link_id' => $link->id,
                'slug' => $context['slug'],
                'ip' => $context['ip'],
                'user_agent' => substr($context['user_agent'] ?? '', 0, 200),
                'status' => 'emergency_fallback'
            ];

            $logFile = storage_path('logs/emergency-metrics.log');
            file_put_contents($logFile, json_encode($emergencyData) . "\n", FILE_APPEND | LOCK_EX);

            \Log::critical('üÜò Emergency metrics fallback activated', array_merge($context, [
                'fallback_method' => 'file_storage',
                'emergency_file' => $logFile,
                'message' => 'All primary metrics systems failed, using emergency fallback'
            ]));
        } catch (\Throwable $e) {
            // Se at√© o fallback de emerg√™ncia falhar, apenas registra no error_log
            error_log("LinkChart CRITICAL: All metrics systems failed for slug {$context['slug']} - " . $e->getMessage());
        }
    }
}
